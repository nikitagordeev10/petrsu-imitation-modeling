// ================================= Генерация выборки методом отклонения (Неймана) =================================

// Функция для генерации случайного числа из заданного распределения методом Неймана
// Метод Неймана заключается в генерации точек в ограничивающем прямоугольнике
// и принятии только тех точек, которые попадают под кривую плотности распределения
Функция СгенерироватьСлучайноеЧисло()
	// Бесконечный цикл, пока не сгенерируем подходящее значение
	Пока Истина Цикл 
		// Генерируем случайную точку x равномерно на [0, 2π]
		СлучайнаяТочкаX = 2 * Математика.Пи() * Математика.СлучайноеЧислоОт0До1();
		
		// Генерируем случайную точку y до верхней границы плотности (3/(4π))
		СлучайнаяТочкаY = Математика.СлучайноеЧислоОт0До1() * (3.0 / (4 * Математика.Пи())); 
		
		// Проверяем, попадает ли точка под кривую плотности распределения
		Если СлучайнаяТочкаY <= (2 + Cos(СлучайнаяТочкаX)) / (4 * Математика.Пи()) Тогда
            Возврат СлучайнаяТочкаX;
        КонецЕсли;
    КонецЦикла;
КонецФункции

// ================================= Проверка гипотезы согласия (Колмогоров-Смирнов) =================================

// Функция для вычисления эмпирической функции распределения
Функция РассчитатьЭмпирическуюФункциюРаспределения(Выборка, МассивЭФР) 
    // ЭФР в точке x - это доля элементов выборки, которые ≤ x
    // Для отсортированной выборки ЭФР вычисляется просто как (i+1)/n
	Для Индекс = 0 По Выборка.Количество() - 1 Цикл
        МассивЭФР[Индекс] = (Индекс + 1) / Выборка.Количество();
    КонецЦикла;
КонецФункции

// Теоретическая функция распределения (интеграл от плотности)
// АргументX - точка, в которой вычисляется значение ЭФР
Функция ВычислитьТеоретическуюФункциюРаспределения(АргументX)
	// Граничные случаи
	Если АргументX <= 0 Тогда
        Возврат 0;
    ИначеЕсли АргументX >= 2 * Математика.Пи() Тогда
        Возврат 1;
    КонецЕсли;
	
	// Численное интегрирование плотности распределения от 0 до АргументX
    ЗначениеИнтеграла = 0.0;
    КоличествоШагов = 500;
    ШагИнтегрирования = АргументX / КоличествоШагов;
	
	// Метод прямоугольников для вычисления интеграла
    Для Индекс = 0 По КоличествоШагов - 1 Цикл
        ТекущаяТочка = Индекс * ШагИнтегрирования;
        ЗначениеИнтеграла = ЗначениеИнтеграла + (2 + Cos(ТекущаяТочка)) * ШагИнтегрирования;
	КонецЦикла;
	
	// Нормировка на (4π) согласно заданной плотности
    Возврат ЗначениеИнтеграла / (4 * Математика.Пи());
КонецФункции

// Критерий Колмогорова-Смирнова для проверки гипотезы согласия
// Выборка - массив значений случайной величины
// Возвращает статистику D - максимальное отклонение между теоретической и эмпирической ФР
Функция ВычислитьСтатистикуКолмогороваСмирнова(Выборка)
	// Сортируем выборку по возрастанию
	Математика.СортироватьМассивПоВозрастанию(Выборка);
	
	// Вычисляем эмпирическую функцию распределения
	МассивЭФР = Новый Массив(Выборка.Количество());
    РассчитатьЭмпирическуюФункциюРаспределения(Выборка, МассивЭФР);
	
	// Находим максимальное отклонение между теоретической и эмпирической ФР
	МаксимальноеОтклонение = 0.0;
    
    Для Индекс = 0 По Выборка.Количество() - 1 Цикл
        ТеоретическаяФР = ВычислитьТеоретическуюФункциюРаспределения(Выборка[Индекс]);
        ТекущееОтклонение = Математика.Модуль(МассивЭФР[Индекс] - ТеоретическаяФР);
		
		Если ТекущееОтклонение > МаксимальноеОтклонение Тогда
            МаксимальноеОтклонение = ТекущееОтклонение;
        КонецЕсли;
    КонецЦикла;
	
	Возврат МаксимальноеОтклонение;
КонецФункции

// Функция для получения критического значения критерия Колмогорова-Смирнова
// РазмерВыборки - объем выборки
// Возвращает критическое значение для уровня значимости 0.05
Функция ПолучитьКритическоеЗначение(РазмерВыборки)
	// Критическое значение для α=0.05: Dкрит ≈ 1.36/√n
	Возврат 1.36 / Математика.КвадратныйКорень(РазмерВыборки);
КонецФункции

// ================================= Команды формы =================================

&НаКлиенте
Процедура СгенерироватьВыборкуИПроверитьГипотезуСогласия(Команда)
	
	// Параметры выборки
    РазмерВыборки = 1000; 
    Выборка = Новый Массив(РазмерВыборки);
    
    // Генерация выборки
    Для Индекс = 0 По РазмерВыборки - 1 Цикл
        Выборка[Индекс] = СгенерироватьСлучайноеЧисло();
    КонецЦикла;
	
	// Заполнение таблицы значений
    Объект.Выборка.Очистить();
    Для Индекс = 0 По РазмерВыборки - 1 Цикл
        НоваяСтрока = Объект.Выборка.Добавить();
        НоваяСтрока.ЭлементВыборки = Индекс + 1;
        НоваяСтрока.ЗначениеЭлемента = Выборка[Индекс];
    КонецЦикла;
    
    // Обновление диаграммы
    ОбновитьДиаграммуЭлементовНаСервере();
	ОбновитьДиаграммуРаспределенияНаСервере();
	
    // Проверка гипотезы согласия критерием Колмогорова-Смирнова
    СтатистикаD = ВычислитьСтатистикуКолмогороваСмирнова(Выборка);
    КритическоеЗначение = ПолучитьКритическоеЗначение(РазмерВыборки);
    
   // Вывод результатов
    Сообщить("Результаты проверки гипотезы согласия:");
    Сообщить("----------------------------------");
    Сообщить("Размер выборки: " + РазмерВыборки);
    Сообщить("Статистика Колмогорова-Смирнова (D): " + СтатистикаD);
    Сообщить("Критическое значение (α=0.05): " + КритическоеЗначение);
    
    // 6. Принятие решения о гипотезе
    Если СтатистикаD < КритическоеЗначение Тогда
        Сообщить("Вывод: Гипотеза не отвергается (данные соответствуют распределению)");
    Иначе
        Сообщить("Вывод: Гипотеза отвергается (данные не соответствуют распределению)");
    КонецЕсли;
    
КонецПроцедуры      

// ================================= Функции для отображения данных =================================

&НаСервере
Процедура ОбновитьДиаграммуЭлементовНаСервере()
	
	Объект.ДиаграммаЭлементы.Очистить();
	Объект.ДиаграммаЭлементы.АвтоТранспонирование = Ложь;
	Объект.ДиаграммаЭлементы.Обновление = Ложь;
	
	Объект.ДиаграммаЭлементы.Серии.Добавить("Гистограмма выборки");
	
	Для Каждого ТекСтрока Из Объект.Выборка Цикл
		Точка = Объект.ДиаграммаЭлементы.УстановитьТочку(ТекСтрока.ЭлементВыборки);
		
		Объект.ДиаграммаЭлементы.УстановитьЗначение(Точка, Объект.ДиаграммаЭлементы.Серии[0], 
		ТекСтрока.ЗначениеЭлемента, Неопределено, "ЗначениеЭлемента");					
		
	КонецЦикла;
	
	Объект.ДиаграммаЭлементы.АвтоТранспонирование = Истина;
	Объект.ДиаграммаЭлементы.Обновление = Истина;
	
КонецПроцедуры


&НаСервере
Процедура ОбновитьДиаграммуРаспределенияНаСервере()
    
    Объект.ДиаграммаРаспределения.Очистить();
    Объект.ДиаграммаРаспределения.АвтоТранспонирование = Ложь;
    Объект.ДиаграммаРаспределения.Обновление = Ложь;
    
    // Создаем структуру для подсчета повторений
    Счетчик = Новый Соответствие();
	
	Для Индекс = 0 По 6 Цикл
		ОбратныйИндекс = 6 - Индекс;
        Счетчик.Вставить(ОбратныйИндекс, 0);
	КонецЦикла;
	
    // Подсчитываем количество каждого элемента
    Для Каждого ТекСтрока Из Объект.Выборка Цикл
        Ключ = Окр(ТекСтрока.ЗначениеЭлемента);
        Если Счетчик.Получить(Ключ) <> Неопределено Тогда
            Счетчик[Ключ] = Счетчик[Ключ] + 1;
        Иначе
            Счетчик.Вставить(Ключ, 1);
        КонецЕсли;
    КонецЦикла;
	
	
   Объект.ДиаграммаРаспределения.Серии.Добавить("Частота встречаемости");
    
    // Заполняем диаграмму данными
    Для Каждого Элемент Из Счетчик Цикл
        Точка = Объект.ДиаграммаРаспределения.УстановитьТочку(Элемент.Ключ);
        
        Объект.ДиаграммаРаспределения.УстановитьЗначение(Точка, Объект.ДиаграммаРаспределения.Серии[0], 
        Элемент.Значение, Неопределено, "Количество");	
    КонецЦикла;
    
    Объект.ДиаграммаРаспределения.АвтоТранспонирование = Истина;
    Объект.ДиаграммаРаспределения.Обновление = Истина;

КонецПроцедуры





