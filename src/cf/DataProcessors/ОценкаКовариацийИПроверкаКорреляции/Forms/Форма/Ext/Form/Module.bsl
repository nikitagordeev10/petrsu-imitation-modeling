// ================================= Генерация выборки методом Холецкого (разложение матрицы ковариации) =================================

Процедура РазложитьМатрицуХолецкого(МатрицаКовариации, НижняяТреугольнаяМатрица, Размерность)
    Для Строка = 0 По Размерность - 1 Цикл
        Для Столбец = 0 По Строка Цикл
            СуммаПроизведений = 0;
            Для Индекс = 0 По Столбец - 1 Цикл
                СуммаПроизведений = СуммаПроизведений + НижняяТреугольнаяМатрица[Строка][Индекс] * НижняяТреугольнаяМатрица[Столбец][Индекс];
			КонецЦикла;
            Если Строка = Столбец Тогда
				// Для диагональных элементов (i = j):
				НижняяТреугольнаяМатрица[Строка][Столбец] = SQRT(МатрицаКовариации[Строка][Строка] - СуммаПроизведений);
			Иначе
				// Для внедиагональных элементов (i > j)
                НижняяТреугольнаяМатрица[Строка][Столбец] = (МатрицаКовариации[Строка][Столбец] - СуммаПроизведений) / НижняяТреугольнаяМатрица[Столбец][Столбец];
            КонецЕсли;
        КонецЦикла;
    КонецЦикла;
КонецПроцедуры

// Генерирует выборку из многомерного нормального распределения
Процедура СгенерироватьМногомерноеНормальноеРаспределение(Размерность, ЧислоНаблюдений, ВекторСредних, МатрицаКовариации, Выборка)
	
	// Чтобы потом превратить независимые случайные величины в зависимые (коррелированные).
	НижняяТреугольнаяМатрица = Новый Массив(Размерность, Размерность);
    РазложитьМатрицуХолецкого(МатрицаКовариации, НижняяТреугольнаяМатрица, Размерность);
	
	// Генерация стандартных нормальных величин методом Бокса-Мюллера
    Для НомерНаблюдения = 0 По ЧислоНаблюдений - 1 Цикл
        СтандартныеНормальныеВеличины = Новый Массив(Размерность);
		
		Для НомерПеременной = 0 По Размерность - 1 Цикл
			// Генерируются независимые случайные числа, распределённые по стандартному нормальному закону
            СтандартныеНормальныеВеличины[НомерПеременной] = SQRT(-2 * Log(Макс(Математика.СлучайноеЧислоОт0До1(), 0.000001))) * COS(2 * Математика.Пи() * Математика.СлучайноеЧислоОт0До1());
        КонецЦикла;
		
		// Преобразование в многомерное нормальное распределение
        Для НомерПеременной1 = 0 По Размерность - 1 Цикл
            Выборка[НомерНаблюдения][НомерПеременной1] = ВекторСредних[НомерПеременной1];
            Для НомерПеременной2 = 0 По НомерПеременной1 Цикл
				// Получаем коррелированные данные
				Выборка[НомерНаблюдения][НомерПеременной1] = Выборка[НомерНаблюдения][НомерПеременной1] + НижняяТреугольнаяМатрица[НомерПеременной1][НомерПеременной2] * СтандартныеНормальныеВеличины[НомерПеременной2];
            КонецЦикла;
        КонецЦикла;
    КонецЦикла;
КонецПроцедуры

// ================================= Вычисляет выборочную матрицу ковариации =================================

Процедура ВычислитьВыборочнуюМатрицуКовариации(Размерность, ЧислоНаблюдений, Выборка, ВыборочнаяМатрицаКовариации)
    // Создание вектора для хранения выборочных средних значений по каждой переменной
    ВекторВыборочныхСредних = Новый Массив(Размерность);
    
    // Вычисление выборочных средних (среднее значение каждой переменной по всем наблюдениям)
    Для НомерПеременной = 0 По Размерность - 1 Цикл
        ВекторВыборочныхСредних[НомерПеременной] = 0;
        // Суммируем значения переменной по всем наблюдениям
        Для НомерНаблюдения = 0 По ЧислоНаблюдений - 1 Цикл
            ВекторВыборочныхСредних[НомерПеременной] = ВекторВыборочныхСредних[НомерПеременной] + Выборка[НомерНаблюдения][НомерПеременной];
        КонецЦикла;
        // Делим сумму на количество наблюдений, получая среднее
        ВекторВыборочныхСредних[НомерПеременной] = ВекторВыборочныхСредних[НомерПеременной] / ЧислоНаблюдений;
    КонецЦикла;
    
    // Вычисление элементов выборочной матрицы ковариации
    Для НомерПеременной1 = 0 По Размерность - 1 Цикл
        Для НомерПеременной2 = 0 По Размерность - 1 Цикл
            // Инициализируем элемент матрицы ковариации нулем
            ВыборочнаяМатрицаКовариации[НомерПеременной1][НомерПеременной2] = 0;
            // Считаем сумму произведений отклонений от средних для каждой пары переменных
            Для НомерНаблюдения = 0 По ЧислоНаблюдений - 1 Цикл
                Отклонение1 = Выборка[НомерНаблюдения][НомерПеременной1] - ВекторВыборочныхСредних[НомерПеременной1];
                Отклонение2 = Выборка[НомерНаблюдения][НомерПеременной2] - ВекторВыборочныхСредних[НомерПеременной2];
                ВыборочнаяМатрицаКовариации[НомерПеременной1][НомерПеременной2] = ВыборочнаяМатрицаКовариации[НомерПеременной1][НомерПеременной2] + Отклонение1 * Отклонение2;
            КонецЦикла;
            // Делим сумму на (n - 1), получая выборочную ковариацию
            ВыборочнаяМатрицаКовариации[НомерПеременной1][НомерПеременной2] = ВыборочнаяМатрицаКовариации[НомерПеременной1][НомерПеременной2] / (ЧислоНаблюдений - 1);
        КонецЦикла;
    КонецЦикла;
КонецПроцедуры

// ================================= Проверяет гипотезу о равенстве коэффициента корреляции заданному значению =================================

Процедура ПроверитьГипотезуОКорреляции(Размерность, ЧислоНаблюдений, ВыборочнаяМатрицаКовариации, НомерПервойПеременной, НомерВторойПеременной, ГипотетическаяКорреляция)
    // Вычисление выборочной корреляции
	// Корреляция — это нормированная ковариация: от -1 до 1
    Ковариация = ВыборочнаяМатрицаКовариации[НомерПервойПеременной][НомерВторойПеременной];
    Дисперсия1 = ВыборочнаяМатрицаКовариации[НомерПервойПеременной][НомерПервойПеременной];
    Дисперсия2 = ВыборочнаяМатрицаКовариации[НомерВторойПеременной][НомерВторойПеременной];
    ВыборочнаяКорреляция = Ковариация / SQRT(Дисперсия1 * Дисперсия2);
    
    // Преобразование Фишера для корреляции (Z-преобразование)
    // Это нужно, чтобы преобразовать корреляцию в нормальное распределение
    ZВыборочное = 0.5 * log10((1 + ВыборочнаяКорреляция) / (1 - ВыборочнаяКорреляция));
    ZГипотетическое = 0.5 * log10((1 + ГипотетическаяКорреляция) / (1 - ГипотетическаяКорреляция));
	
	// Z-статистика: насколько далеко выборочная корреляция от гипотетической
	ZСтатистика = (ZВыборочное - ZГипотетическое) * SQRT(ЧислоНаблюдений - 3);
    
    // p-значение: вероятность получить такое отклонение, если H0 верна
	// используем стандартное нормальное распределение N(0,1)
    PЗначение = 2 * (1 - НормальноеРаспределение(Математика.Модуль(ZСтатистика)));
    
    // Вывод промежуточных результатов
    Сообщить("Оценка матрицы ковариаций:");
    Для i = 0 По Размерность - 1 Цикл
        Строка = "";
        Для j = 0 По Размерность - 1 Цикл
            Строка = Строка + Формат(ВыборочнаяМатрицаКовариации[i][j], "ЧДЦ=4") + " ";
        КонецЦикла;
        Сообщить(Строка);
    КонецЦикла;
    
    Сообщить("Выборочный коэффициент корреляции Cor(X" + НомерПервойПеременной + ", X" + НомерВторойПеременной + "): " + Формат(ВыборочнаяКорреляция, "ЧДЦ=4"));
    Сообщить("Z-статистика: " + Формат(ZСтатистика, "ЧДЦ=4"));
    Сообщить("P-значение: " + Формат(PЗначение, "ЧДЦ=6"));
    
    // Принятие или отклонение гипотезы на уровне значимости α = 0.05
    Если PЗначение < 0.05 Тогда
        Сообщить("Гипотеза отвергается: Cor(X" + НомерПервойПеременной + ", X" + НомерВторойПеременной + ") ≠ " + ГипотетическаяКорреляция);
    Иначе
        Сообщить("Гипотеза не отвергается: Cor(X" + НомерПервойПеременной + ", X" + НомерВторойПеременной + ") = " + ГипотетическаяКорреляция);
    КонецЕсли;
КонецПроцедуры

// Функция нормального распределения (аппроксимация)
Функция НормальноеРаспределение(Знач СтандартизированноеОтклонение)
    // Эта функция вычисляет вероятность того, что случайная величина 
    // из стандартного нормального распределения (среднее=0, дисперсия=1)
    // примет значение меньше или равное заданному z-значению
    
    // Константы для аппроксимации функции ошибок (error function)
    // Используется аппроксимация Абрамовица и Стегана (формула 7.1.26)
    КоэффициентАппроксимации1 =  0.254829592;
    КоэффициентАппроксимации2 = -0.284496736;
    КоэффициентАппроксимации3 =  1.421413741;
    КоэффициентАппроксимации4 = -1.453152027;
    КоэффициентАппроксимации5 =  1.061405429;
    ПараметрМасштабирования    =  0.3275911;
    
    // Определяем направление отклонения (левостороннее или правостороннее)
    НаправлениеОтклонения = 1;  // По умолчанию для положительных значений
    Если СтандартизированноеОтклонение < 0 Тогда
        НаправлениеОтклонения = -1;  // Для отрицательных значений
    КонецЕсли;
    
    // Нормализуем значение для вычислений
    АбсолютноеОтклонение = Математика.Модуль(СтандартизированноеОтклонение);
    НормированноеОтклонение = АбсолютноеОтклонение / SQRT(2.0);
    
    // Вычисляем промежуточные значения для аппроксимации
    ВременныйКоэффициент = 1.0 / (1.0 + ПараметрМасштабирования * НормированноеОтклонение);
    
    // Многоэтапное вычисление полиномиальной аппроксимации
    ПолиномиальнаяАппроксимация = ((((
        КоэффициентАппроксимации5 * ВременныйКоэффициент + 
        КоэффициентАппроксимации4) * ВременныйКоэффициент + 
        КоэффициентАппроксимации3) * ВременныйКоэффициент + 
        КоэффициентАппроксимации2) * ВременныйКоэффициент + 
        КоэффициентАппроксимации1) * ВременныйКоэффициент;
    
    // Корректируем результат с учетом экспоненциального убывания
    РезультатАппроксимации = 1.0 - ПолиномиальнаяАппроксимация * EXP(-НормированноеОтклонение * НормированноеОтклонение);
    
    // Масштабируем результат с учетом направления
    Вероятность = 0.5 * (1.0 + НаправлениеОтклонения * РезультатАппроксимации);
    
    Возврат Вероятность;
КонецФункции
// ================================= Команды формы =================================

&НаКлиенте
Процедура ПроверитьГипотезу(Команда)
    // Параметры распределения
    Размерность = 3;
    ЧислоНаблюдений = 1000;
    
    // Задание параметров распределения
	
	// Вектор средних (математических ожиданий), например, переменные центрированы вокруг нуля	
    ВекторСредних = Новый Массив(Размерность);
    ВекторСредних[0] = 0; ВекторСредних[1] = 0; ВекторСредних[2] = 0;
	
	// Дисперсии каждой переменной (на диагонали), ковариации (корреляции) между переменными (вне диагонали)
	// Cov(X1, X2) = 0.5 (положительная корреляция).
	// Cov(X1, X3) = 0.2  (слабая корреляция).
	// Матрица должна быть симметричной, положительно определённой
	МатрицаКовариации = Новый Массив(Размерность, Размерность);
    МатрицаКовариации[0][0] = 1.0; МатрицаКовариации[0][1] = 0.5; МатрицаКовариации[0][2] = 0.2;
    МатрицаКовариации[1][0] = 0.5; МатрицаКовариации[1][1] = 1.0; МатрицаКовариации[1][2] = 0.3;
    МатрицаКовариации[2][0] = 0.2; МатрицаКовариации[2][1] = 0.3; МатрицаКовариации[2][2] = 1.0;
    
    // Инициализация массивов
    Выборка = Новый Массив(ЧислоНаблюдений, Размерность);
    ВыборочнаяМатрицаКовариации = Новый Массив(Размерность, Размерность);
    
    // 1. Генерация выборки
    СгенерироватьМногомерноеНормальноеРаспределение(Размерность, ЧислоНаблюдений, ВекторСредних, МатрицаКовариации, Выборка);
    
    // 2. Вычисление выборочных характеристик
    ВычислитьВыборочнуюМатрицуКовариации(Размерность, ЧислоНаблюдений, Выборка, ВыборочнаяМатрицаКовариации);
    
    // 3. Проверка гипотезы о корреляции
	// Выбираем две переменные для анализа 
    НомерПервойПеременной = 0;
    НомерВторойПеременной = 1;
    ГипотетическаяКорреляция = 0.5;
    ПроверитьГипотезуОКорреляции(Размерность, ЧислоНаблюдений, ВыборочнаяМатрицаКовариации, НомерПервойПеременной, НомерВторойПеременной, ГипотетическаяКорреляция);
КонецПроцедуры