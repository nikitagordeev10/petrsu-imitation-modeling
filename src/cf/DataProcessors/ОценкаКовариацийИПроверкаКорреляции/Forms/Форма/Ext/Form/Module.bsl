Функция Пи()
    Возврат 3.1415926535897932384626433832795;
КонецФункции

Функция РазложениеХолецкого(Матрица)
    n = Матрица.Количество();
    L = Новый Массив(n, n);
    Для i = 0 По n - 1 Цикл
        Для j = 0 По i Цикл
            Сумма = 0;
            Для k = 0 По j - 1 Цикл
                Сумма = Сумма + L[i][k] * L[j][k];
            КонецЦикла;
            Если i = j Тогда
                L[i][j] = Sqrt(Матрица[i][i] - Сумма);
            Иначе
                L[i][j] = (Матрица[i][j] - Сумма) / L[j][j];
            КонецЕсли;
        КонецЦикла;
    КонецЦикла;
    Возврат L;
КонецФункции

Функция НормальноеРаспределение(mean, stddev)    
    ГСЧ = Новый ГенераторСлучайныхЧисел();
    u1 = ГСЧ.СлучайноеЧисло(1, 2); // Избегаем нуля
    u2 = ГСЧ.СлучайноеЧисло(0.0001, 1); // Избегаем нуля
    z0 = Cos(2 * Пи() * u2);

    Возврат mean + stddev * z0;
КонецФункции

Функция ГенерацияМногомерногоНормальногоРаспределения(n_samples, mu, sigma)
    n = mu.Количество();
    L = РазложениеХолецкого(sigma);
    z = Новый Массив(n, n_samples);
    Для i = 0 По n - 1 Цикл
        Для j = 0 По n_samples - 1 Цикл
            z[i][j] = НормальноеРаспределение(0, 1); // Заполняем числами
        КонецЦикла;
    КонецЦикла;

    samples = Новый Массив(n_samples, n);
    Для i = 0 По n_samples - 1 Цикл
        Для j = 0 По n - 1 Цикл
            samples[i][j] = 0; // Инициализируем нулями
            Для k = 0 По n - 1 Цикл
                // Убедимся, что L[j][k] и z[k][i] являются числами
                samples[i][j] = samples[i][j] + L[j][k] * z[k][i];
            КонецЦикла;
            samples[i][j] = samples[i][j] + mu[j]; // Добавляем среднее значение
        КонецЦикла;
    КонецЦикла;
    Возврат samples;
КонецФункции

Функция ОценкаМатрицыКовариации(samples)
    n_samples = samples.Количество();
    n = samples[0].Количество();
    mean = Новый Массив(n);
    Для i = 0 По n - 1 Цикл
        mean[i] = 0;
        Для j = 0 По n_samples - 1 Цикл
            mean[i] = mean[i] + samples[j][i];
        КонецЦикла;
        mean[i] = mean[i] / n_samples;
    КонецЦикла;
    cov_matrix = Новый Массив(n, n);
    Для i = 0 По n - 1 Цикл
        Для j = 0 По n - 1 Цикл
            cov_matrix[i][j] = 0;
            Для k = 0 По n_samples - 1 Цикл
                cov_matrix[i][j] = cov_matrix[i][j] + (samples[k][i] - mean[i]) * (samples[k][j] - mean[j]);
            КонецЦикла;
            cov_matrix[i][j] = cov_matrix[i][j] / (n_samples - 1);
        КонецЦикла;
    КонецЦикла;
    Возврат cov_matrix;
КонецФункции

Функция КоэффициентКорреляцииПирсона(x, y)
    n = x.Количество();
    mean_x = СреднееЗначение(x);
    mean_y = СреднееЗначение(y);
    cov = 0;
    var_x = 0;
    var_y = 0;
    Для i = 0 По n - 1 Цикл
        cov = cov + (x[i] - mean_x) * (y[i] - mean_y);
        var_x = var_x + (x[i] - mean_x) * (x[i] - mean_x);
        var_y = var_y + (y[i] - mean_y) * (y[i] - mean_y);
    КонецЦикла;
    corr = cov / Sqrt(var_x * var_y);
    Возврат corr;
КонецФункции

Функция СреднееЗначение(массив)
    сумма = 0;
    Для каждого элемент Из массив Цикл
        сумма = сумма + элемент;
    КонецЦикла;
    Возврат сумма / массив.Количество();
КонецФункции

Функция pValueКоэффициентаКорреляции(corr, n)
    t = corr * Sqrt((n - 2) / (1 - corr * corr));
    p_value = 2 * (1 - РаспределениеСтьюдента(t, n - 2));
    Возврат p_value;
КонецФункции

Функция РаспределениеСтьюдента(t, df)
    x = df / (df + t * t);
    a = df / 2;
    b = 0.5;
    beta = БетаФункция(x, a, b);
    Возврат 1 - 0.5 * beta;
КонецФункции

Функция БетаФункция(x, a, b)
    Если x <= 0 Или x >= 1 Тогда
        Возврат 0;
    КонецЕсли;
    beta = 0;
    Для i = 0 По 100 Цикл
        beta = beta + Pow(x, i + a) * Pow(1 - x, i + b) / (Факториал(i) * (i + a));
    КонецЦикла;
    Возврат beta;
КонецФункции

Функция Факториал(n)
    Если n = 0 Тогда
        Возврат 1;
    Иначе
        Возврат n * Факториал(n - 1);
    КонецЕсли;
КонецФункции

&НаКлиенте
Процедура Сгенерировать(Команда)

    // Задаем параметры
    n = 3; // Размерность вектора
    n_samples = 1000;
    mu = Новый Массив(3);
    mu[0] = 0;
    mu[1] = 0;
    mu[2] = 0; // Нулевой вектор средних
    sigma = Новый Массив(3, 3);
    sigma[0][0] = 1;
    sigma[0][1] = 0.5;
    sigma[0][2] = 0.2;
    sigma[1][0] = 0.5;
    sigma[1][1] = 1;
    sigma[1][2] = 0.3;
    sigma[2][0] = 0.2;
    sigma[2][1] = 0.3;
    sigma[2][2] = 1; // Матрица ковариаций

    // Генерация выборки
    samples = ГенерацияМногомерногоНормальногоРаспределения(n_samples, mu, sigma);

    // Оценка матрицы ковариаций
    sample_cov_matrix = ОценкаМатрицыКовариации(samples);
    Сообщить("Оцененная матрица ковариаций:");
    Для i = 0 По n - 1 Цикл
        строка = "";
        Для j = 0 По n - 1 Цикл
            строка = строка + sample_cov_matrix[i][j] + " ";
        КонецЦикла;
        Сообщить(строка);
    КонецЦикла;

    // Проверка гипотезы о коэффициенте корреляции
    idx_i = 0;
    idx_j = 1; // Проверяем корреляцию между X1 и X2
    x = Новый Массив(n_samples);
    y = Новый Массив(n_samples);
    Для i = 0 По n_samples - 1 Цикл
        x[i] = samples[i][idx_i];
        y[i] = samples[i][idx_j];
    КонецЦикла;
    corr_coef = КоэффициентКорреляцииПирсона(x, y);
    p_value = pValueКоэффициентаКорреляции(corr_coef, n_samples);
    Сообщить("Оцененный коэффициент корреляции между X" + (idx_i + 1) + " и X" + (idx_j + 1) + ": " + corr_coef);
    Сообщить("p-value: " + p_value);
    Если p_value > 0.05 Тогда
        Сообщить("Нет оснований отвергнуть гипотезу о равенстве коэффициента корреляции заданному значению");
    Иначе
        Сообщить("Гипотеза о равенстве коэффициента корреляции отвергается");
    КонецЕсли;

КонецПроцедуры