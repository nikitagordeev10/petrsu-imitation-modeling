// Функция для генерации случайного направления (0-вниз, 1-вправо, 2-вверх, 3-влево)
Функция СлучайноеНаправление()
    ГСЧ = Новый ГенераторСлучайныхЧисел();
    Возврат ГСЧ.СлучайноеЧисло(0, 3);
КонецФункции

// Проверка на самопересечение
Функция ЕстьСамопересечение(x_path, y_path, Длина)
    Для i = 0 По Длина - 2 Цикл
        Если x_path[i] = x_path[Длина - 1] И y_path[i] = y_path[Длина - 1] Тогда
            Возврат Ложь; // Нашли самопересечение
        КонецЕсли;
    КонецЦикла;
    Возврат Истина; // Нет самопересечений
КонецФункции

// Функция для генерации случайного блуждания
Функция СлучайноеБлуждание(Длина, РазмерМатрицы)
    x_path = Новый Массив;
    y_path = Новый Массив;
    x_path.Добавить(0);
    y_path.Добавить(0);

    // Инициализируем сетку
    Сетка = Новый Массив(РазмерМатрицы);
    Для i = 0 По РазмерМатрицы - 1 Цикл
        Сетка[i] = Новый Массив(РазмерМатрицы);
        Для j = 0 По РазмерМатрицы - 1 Цикл
            Сетка[i][j] = ".";
        КонецЦикла;
    КонецЦикла;

    // Начало в левом верхнем углу
    Сетка[0][0] = "O";  // Стартовая позиция

    ТекущаяДлина = 1;
    ТекущийX = 0;
    ТекущийY = 0;

    Пока ТекущаяДлина < Длина Цикл
        Направление = СлучайноеНаправление();
        НовыйX = ТекущийX;
        НовыйY = ТекущийY;

        // Двигаемся в случайном направлении
        Если Направление = 0 Тогда
            НовыйX = НовыйX + 1;  // Вниз
        ИначеЕсли Направление = 1 Тогда
            НовыйY = НовыйY + 1;  // Вправо
        ИначеЕсли Направление = 2 И НовыйX > 0 Тогда
            НовыйX = НовыйX - 1;  // Вверх (если не на верхней границе)
        ИначеЕсли Направление = 3 И НовыйY > 0 Тогда
            НовыйY = НовыйY - 1;  // Влево (если не в крайнем левом столбце)
        КонецЕсли;

        x_path.Добавить(НовыйX);
        y_path.Добавить(НовыйY);

        Если ЕстьСамопересечение(x_path, y_path, ТекущаяДлина + 1) Тогда
            ТекущийX = НовыйX;
            ТекущийY = НовыйY;
            Сетка[ТекущийX][ТекущийY] = "X";  // Отмечаем путь
            ТекущаяДлина = ТекущаяДлина + 1;
        Иначе
            // Если самопересечение, удаляем последнюю точку и пробуем снова
            x_path.Удалить(ТекущаяДлина);
            y_path.Удалить(ТекущаяДлина);
        КонецЕсли;
    КонецЦикла;

    Возврат Новый Структура("КонечныйX, КонечныйY, Сетка", ТекущийX, ТекущийY, Сетка);
КонецФункции

// Функция для вычисления расстояния между началом и концом
Функция РасстояниеОтНачала(x, y)
    Возврат Sqrt(x * x + y * y);
КонецФункции

// Функция для вывода матрицы блуждания
Функция ВывестиСетку(Сетка, РазмерМатрицы)
    Для i = 0 По РазмерМатрицы - 1 Цикл
        Строка = "";
        Для j = 0 По РазмерМатрицы - 1 Цикл
            Строка = Строка + Сетка[i][j] + " ";
        КонецЦикла;
        Сообщить(Строка);
    КонецЦикла;
    Сообщить("");
КонецФункции

&НаКлиенте
Процедура Сгенерировать(Команда)
    КоличествоБлужданий = 10;    // Количество блужданий
	ДлинаБлуждания = 8;         // Длина блуждания
	РазмерМатрицы = 12;          // Размер сетки (достаточно большой для случайных блужданий)

    ОбщееРасстояние = 0.0;   
	
    // Запуск нескольких блужданий
    Для i = 1 По КоличествоБлужданий Цикл
        Результат = СлучайноеБлуждание(ДлинаБлуждания, РазмерМатрицы);
        КонечныйX = Результат.КонечныйX;
        КонечныйY = Результат.КонечныйY;
        Сетка = Результат.Сетка;

        ОбщееРасстояние = ОбщееРасстояние + РасстояниеОтНачала(КонечныйX, КонечныйY);

        // Выводим матрицу текущего блуждания
        Сообщить("Блуждание #" + i + ":");
        ВывестиСетку(Сетка, РазмерМатрицы);
        Сообщить("Конечная точка: (" + КонечныйX + ", " + КонечныйY + ")");
    КонецЦикла;

    // Среднее расстояние
    СреднееРасстояние = ОбщееРасстояние / КоличествоБлужданий;
    Сообщить("Среднее расстояние от (0,0) до конечной точки для блужданий длины " + ДлинаБлуждания + ": " + СреднееРасстояние);
КонецПроцедуры